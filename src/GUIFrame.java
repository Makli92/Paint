/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package paintingEs;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.util.ArrayList;
import java.util.Objects;
import javax.swing.DefaultListModel;
import javax.swing.JColorChooser;
import javax.swing.JOptionPane;
import java.util.regex.*;

/*
 * @author Makli
 */

public final class GUIFrame extends javax.swing.JFrame {
    int DrawPadWidth, DrawPadHeight;
    int DrawPadMaxWidth = 650;
    int DrawPadMaxHeight = 520;
    
    Color toolColor = Color.BLACK;      // The color of the user's tool
    Color backColor = Color.WHITE;      // The color of the background
    Color fillColor = Color.WHITE;      // The color of filling the shape (only Circle, Triangle, Square, Polygon(4 and 5 sides), Rectangular)
    
    int strokeSize = 1;
    boolean filled = false;
    
    int drawMode = 0;                   // 0 = Pencil, 1 = Line, 2 = Circle, 3 = Triangle, 4 = Square, 5 = Polygon 4, 6 = Polygon 5, 7 = Crooked Line, 8 = Rectangular
    int mouseClickCounter = 0;          // Counts the clicks of the mouse after choosing to draw one of the shapes available
    int[] shapesX, shapesY;             // Helping variables in order to save each shape's coordinates
    
    int[] minY, maxY;                   // Helping arrays for saving scan lines, serve 
    double[] slope, valueX;             // in filling polygon methods(triangle included)
    
    /* Define helping list models for saving shapes' elements */
    DefaultListModel ShapesListModel = new DefaultListModel();      // Main list which saves the output of the ShapesList
    ArrayList<ArrayList<Integer>> ListOfDetailsLists = new ArrayList<>();       // List made of lists, saves all shapes' elements
    
    /*
     * Creates new form GUIFrame
     */
    
    public GUIFrame() {
        initComponents();
        initComponentsVol2();
        SetDimensions();
    }
    
    /* <---- Initialization code ----> */
    
    /*
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        ToolsPnl = new javax.swing.JPanel();
        ResizeBtn = new javax.swing.JButton();
        ToolShapesLbl = new javax.swing.JLabel();
        LineBtn = new javax.swing.JButton();
        CircleBtn = new javax.swing.JButton();
        TriangleBtn = new javax.swing.JButton();
        SquareBtn = new javax.swing.JButton();
        PencilBtn = new javax.swing.JButton();
        CrookedLineBtn = new javax.swing.JButton();
        ColorLbl = new javax.swing.JLabel();
        ToolColorBtn = new javax.swing.JButton();
        BackgroundColorBtn = new javax.swing.JButton();
        PolygonCmbBx = new javax.swing.JComboBox();
        RectangularBtn = new javax.swing.JButton();
        ClearBtn = new javax.swing.JButton();
        ToolSprtr1 = new javax.swing.JSeparator();
        ToolColorLbl = new javax.swing.JLabel();
        BackgroundColorLbl = new javax.swing.JLabel();
        FillColorLbl = new javax.swing.JLabel();
        ToolSprtr2 = new javax.swing.JSeparator();
        StrokeLbl = new javax.swing.JLabel();
        StrokeSldr = new javax.swing.JSlider();
        ToolSprtr3 = new javax.swing.JSeparator();
        FillColorCmbBx = new javax.swing.JComboBox();
        ListPnl = new javax.swing.JPanel();
        ListShapesLbl = new javax.swing.JLabel();
        ScrollShapesLst = new javax.swing.JScrollPane();
        ShapesLst = new javax.swing.JList();
        DetailsScrollPnl = new javax.swing.JScrollPane();
        DetailsTxtr = new javax.swing.JTextArea();
        DetailsLbl = new javax.swing.JLabel();
        UpBtn = new javax.swing.JButton();
        DownBtn = new javax.swing.JButton();
        EditBtn = new javax.swing.JButton();
        DeleteBtn = new javax.swing.JButton();
        DemoPnl = new javax.swing.JPanel();
        CoordinatesLbl = new javax.swing.JLabel();
        RefreshBtn = new javax.swing.JButton();
        ScrollPnl = new javax.swing.JPanel();
        ScrollDrawPad = new javax.swing.JScrollPane();
        DrawPad = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("My Paint App");
        setBackground(new java.awt.Color(153, 153, 255));
        setMinimumSize(new java.awt.Dimension(1065, 559));
        setResizable(false);

        ToolsPnl.setBackground(new java.awt.Color(204, 204, 255));
        ToolsPnl.setMaximumSize(new java.awt.Dimension(200, 556));
        ToolsPnl.setMinimumSize(new java.awt.Dimension(200, 556));
        ToolsPnl.setPreferredSize(new java.awt.Dimension(200, 556));

        ResizeBtn.setText("Resize");
        ResizeBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ResizeBtnActionPerformed(evt);
            }
        });

        ToolShapesLbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        ToolShapesLbl.setText("Shapes");

        LineBtn.setText("Line");
        LineBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                LineBtnActionPerformed(evt);
            }
        });

        CircleBtn.setText("Circle");
        CircleBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CircleBtnActionPerformed(evt);
            }
        });

        TriangleBtn.setText("Triangle");
        TriangleBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                TriangleBtnActionPerformed(evt);
            }
        });

        SquareBtn.setText("Square");
        SquareBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SquareBtnActionPerformed(evt);
            }
        });

        PencilBtn.setText("Pencil");
        PencilBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PencilBtnActionPerformed(evt);
            }
        });

        CrookedLineBtn.setText("Crooked Line");
        CrookedLineBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CrookedLineBtnActionPerformed(evt);
            }
        });

        ColorLbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        ColorLbl.setText("Colors");

        ToolColorBtn.setText("Tool");
        ToolColorBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ToolColorBtnActionPerformed(evt);
            }
        });

        BackgroundColorBtn.setText("Background");
        BackgroundColorBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                BackgroundColorBtnActionPerformed(evt);
            }
        });

        PolygonCmbBx.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Polygon 4", "Polygon 5" }));
        PolygonCmbBx.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PolygonCmbBxActionPerformed(evt);
            }
        });

        RectangularBtn.setText("Rectangular");
        RectangularBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                RectangularBtnActionPerformed(evt);
            }
        });

        ClearBtn.setText("Clear ");
        ClearBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ClearBtnActionPerformed(evt);
            }
        });

        ToolColorLbl.setBackground(new java.awt.Color(255, 255, 255));
        ToolColorLbl.setForeground(new java.awt.Color(255, 255, 255));

        StrokeLbl.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        StrokeLbl.setText("Stroke");

        StrokeSldr.setBackground(new java.awt.Color(204, 204, 255));
        StrokeSldr.setMaximum(3);
        StrokeSldr.setMinimum(1);
        StrokeSldr.setValue(1);
        StrokeSldr.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                StrokeSldrStateChanged(evt);
            }
        });

        FillColorCmbBx.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "No Fill", "Fill" }));
        FillColorCmbBx.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                FillColorCmbBxActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout ToolsPnlLayout = new javax.swing.GroupLayout(ToolsPnl);
        ToolsPnl.setLayout(ToolsPnlLayout);
        ToolsPnlLayout.setHorizontalGroup(
            ToolsPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(ToolsPnlLayout.createSequentialGroup()
                .addGroup(ToolsPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(ToolsPnlLayout.createSequentialGroup()
                        .addGap(77, 77, 77)
                        .addComponent(ToolShapesLbl))
                    .addGroup(ToolsPnlLayout.createSequentialGroup()
                        .addGap(51, 51, 51)
                        .addGroup(ToolsPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addGroup(ToolsPnlLayout.createSequentialGroup()
                                .addGap(34, 34, 34)
                                .addComponent(ColorLbl))
                            .addComponent(ToolColorBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(BackgroundColorBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(CrookedLineBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(RectangularBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(ToolColorLbl)
                            .addComponent(BackgroundColorLbl)
                            .addComponent(FillColorLbl)
                            .addComponent(FillColorCmbBx, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))))
                .addGap(0, 0, Short.MAX_VALUE))
            .addGroup(ToolsPnlLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(ToolsPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(ToolSprtr1, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(ToolSprtr2, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(ToolSprtr3)
                    .addGroup(ToolsPnlLayout.createSequentialGroup()
                        .addGap(38, 38, 38)
                        .addGroup(ToolsPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(StrokeSldr, javax.swing.GroupLayout.PREFERRED_SIZE, 104, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(ToolsPnlLayout.createSequentialGroup()
                                .addGap(35, 35, 35)
                                .addComponent(StrokeLbl)))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 48, Short.MAX_VALUE))
                    .addGroup(ToolsPnlLayout.createSequentialGroup()
                        .addGroup(ToolsPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(ToolsPnlLayout.createSequentialGroup()
                                .addComponent(PencilBtn)
                                .addGap(18, 18, 18)
                                .addComponent(LineBtn))
                            .addGroup(ToolsPnlLayout.createSequentialGroup()
                                .addComponent(SquareBtn)
                                .addGap(18, 18, 18)
                                .addComponent(PolygonCmbBx, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(ToolsPnlLayout.createSequentialGroup()
                                .addComponent(CircleBtn)
                                .addGap(18, 18, 18)
                                .addComponent(TriangleBtn)))
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(ToolsPnlLayout.createSequentialGroup()
                        .addComponent(ResizeBtn)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(ClearBtn)))
                .addContainerGap())
        );

        ToolsPnlLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {CircleBtn, ClearBtn, LineBtn, PencilBtn, PolygonCmbBx, ResizeBtn, SquareBtn, TriangleBtn});

        ToolsPnlLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {BackgroundColorBtn, BackgroundColorLbl, CrookedLineBtn, FillColorCmbBx, FillColorLbl, RectangularBtn, ToolColorBtn, ToolColorLbl});

        ToolsPnlLayout.setVerticalGroup(
            ToolsPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, ToolsPnlLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(ToolShapesLbl)
                .addGap(10, 10, 10)
                .addGroup(ToolsPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(PencilBtn)
                    .addComponent(LineBtn))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(ToolsPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(CircleBtn)
                    .addComponent(TriangleBtn))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(ToolsPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(SquareBtn)
                    .addComponent(PolygonCmbBx, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(RectangularBtn)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(CrookedLineBtn)
                .addGap(18, 18, 18)
                .addComponent(ToolSprtr1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(ColorLbl)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(ToolColorBtn)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(ToolColorLbl, javax.swing.GroupLayout.PREFERRED_SIZE, 13, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(BackgroundColorBtn)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(BackgroundColorLbl, javax.swing.GroupLayout.PREFERRED_SIZE, 14, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(9, 9, 9)
                .addComponent(FillColorCmbBx, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(FillColorLbl, javax.swing.GroupLayout.PREFERRED_SIZE, 14, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(ToolSprtr2, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(StrokeLbl)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(StrokeSldr, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(ToolSprtr3, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 47, Short.MAX_VALUE)
                .addGroup(ToolsPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(ResizeBtn)
                    .addComponent(ClearBtn))
                .addContainerGap())
        );

        ToolsPnlLayout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {BackgroundColorBtn, FillColorCmbBx, ToolColorBtn});

        ToolsPnlLayout.linkSize(javax.swing.SwingConstants.VERTICAL, new java.awt.Component[] {BackgroundColorLbl, FillColorLbl, ToolColorLbl});

        ListPnl.setBackground(new java.awt.Color(204, 204, 255));
        ListPnl.setMaximumSize(new java.awt.Dimension(182, 556));
        ListPnl.setMinimumSize(new java.awt.Dimension(182, 556));
        ListPnl.setPreferredSize(new java.awt.Dimension(182, 556));

        ListShapesLbl.setText("List of Shapes");

        ScrollShapesLst.setMaximumSize(new java.awt.Dimension(125, 130));
        ScrollShapesLst.setMinimumSize(new java.awt.Dimension(125, 130));
        ScrollShapesLst.setPreferredSize(new java.awt.Dimension(125, 130));

        ShapesLst.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt) {
                ShapesLstValueChanged(evt);
            }
        });
        ScrollShapesLst.setViewportView(ShapesLst);

        DetailsScrollPnl.setMaximumSize(new java.awt.Dimension(125, 75));
        DetailsScrollPnl.setMinimumSize(new java.awt.Dimension(125, 75));
        DetailsScrollPnl.setPreferredSize(new java.awt.Dimension(125, 75));

        DetailsTxtr.setColumns(23);
        DetailsTxtr.setRows(5);
        DetailsTxtr.setMaximumSize(new java.awt.Dimension(125, 75));
        DetailsTxtr.setMinimumSize(new java.awt.Dimension(125, 75));
        DetailsScrollPnl.setViewportView(DetailsTxtr);

        DetailsLbl.setText("Details of Shapes");

        UpBtn.setText("Up");
        UpBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                UpBtnActionPerformed(evt);
            }
        });

        DownBtn.setText("Down");
        DownBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                DownBtnActionPerformed(evt);
            }
        });

        EditBtn.setText("Edit");
        EditBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                EditBtnActionPerformed(evt);
            }
        });

        DeleteBtn.setText("Delete");
        DeleteBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                DeleteBtnActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout ListPnlLayout = new javax.swing.GroupLayout(ListPnl);
        ListPnl.setLayout(ListPnlLayout);
        ListPnlLayout.setHorizontalGroup(
            ListPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(ListPnlLayout.createSequentialGroup()
                .addGroup(ListPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(ListPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addGroup(ListPnlLayout.createSequentialGroup()
                            .addContainerGap()
                            .addComponent(ScrollShapesLst, javax.swing.GroupLayout.DEFAULT_SIZE, 204, Short.MAX_VALUE))
                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, ListPnlLayout.createSequentialGroup()
                            .addGap(77, 77, 77)
                            .addComponent(ListShapesLbl))
                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, ListPnlLayout.createSequentialGroup()
                            .addContainerGap()
                            .addComponent(DetailsScrollPnl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                    .addGroup(ListPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                        .addGroup(ListPnlLayout.createSequentialGroup()
                            .addContainerGap()
                            .addComponent(UpBtn)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(DownBtn))
                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, ListPnlLayout.createSequentialGroup()
                            .addGap(44, 44, 44)
                            .addComponent(EditBtn)
                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                            .addComponent(DeleteBtn)))
                    .addGroup(ListPnlLayout.createSequentialGroup()
                        .addGap(62, 62, 62)
                        .addComponent(DetailsLbl)))
                .addContainerGap(13, Short.MAX_VALUE))
        );

        ListPnlLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {DeleteBtn, DownBtn, EditBtn, UpBtn});

        ListPnlLayout.setVerticalGroup(
            ListPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(ListPnlLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(ListShapesLbl)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(ScrollShapesLst, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(ListPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(UpBtn)
                    .addComponent(DownBtn))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(ListPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(EditBtn)
                    .addComponent(DeleteBtn))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 57, Short.MAX_VALUE)
                .addComponent(DetailsLbl)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(DetailsScrollPnl, javax.swing.GroupLayout.PREFERRED_SIZE, 130, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(132, 132, 132))
        );

        DemoPnl.setBackground(new java.awt.Color(204, 204, 255));
        DemoPnl.setMaximumSize(new java.awt.Dimension(0, 41));
        DemoPnl.setMinimumSize(new java.awt.Dimension(0, 41));

        CoordinatesLbl.setText("Coordinates X, Y :");

        RefreshBtn.setText("Refresh");
        RefreshBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                RefreshBtnActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout DemoPnlLayout = new javax.swing.GroupLayout(DemoPnl);
        DemoPnl.setLayout(DemoPnlLayout);
        DemoPnlLayout.setHorizontalGroup(
            DemoPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(DemoPnlLayout.createSequentialGroup()
                .addGap(23, 23, 23)
                .addComponent(CoordinatesLbl)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(RefreshBtn)
                .addGap(26, 26, 26))
        );
        DemoPnlLayout.setVerticalGroup(
            DemoPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(DemoPnlLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(CoordinatesLbl)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(DemoPnlLayout.createSequentialGroup()
                .addComponent(RefreshBtn)
                .addGap(0, 0, Short.MAX_VALUE))
        );

        ScrollPnl.setBackground(new java.awt.Color(204, 204, 255));
        ScrollPnl.setMaximumSize(new java.awt.Dimension(656, 526));
        ScrollPnl.setMinimumSize(new java.awt.Dimension(656, 526));
        ScrollPnl.setPreferredSize(new java.awt.Dimension(656, 526));

        ScrollDrawPad.setMaximumSize(new java.awt.Dimension(656, 526));
        ScrollDrawPad.setMinimumSize(new java.awt.Dimension(656, 526));
        ScrollDrawPad.setPreferredSize(new java.awt.Dimension(656, 526));

        DrawPad.setBackground(new java.awt.Color(255, 255, 255));
        DrawPad.setMaximumSize(new java.awt.Dimension(650, 520));
        DrawPad.setMinimumSize(new java.awt.Dimension(650, 520));
        DrawPad.setName(""); // NOI18N
        DrawPad.setPreferredSize(new java.awt.Dimension(650, 520));
        DrawPad.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                DrawPadMouseDragged(evt);
            }
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                DrawPadMouseMoved(evt);
            }
        });
        DrawPad.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                DrawPadMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout DrawPadLayout = new javax.swing.GroupLayout(DrawPad);
        DrawPad.setLayout(DrawPadLayout);
        DrawPadLayout.setHorizontalGroup(
            DrawPadLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 654, Short.MAX_VALUE)
        );
        DrawPadLayout.setVerticalGroup(
            DrawPadLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 524, Short.MAX_VALUE)
        );

        ScrollDrawPad.setViewportView(DrawPad);

        javax.swing.GroupLayout ScrollPnlLayout = new javax.swing.GroupLayout(ScrollPnl);
        ScrollPnl.setLayout(ScrollPnlLayout);
        ScrollPnlLayout.setHorizontalGroup(
            ScrollPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 656, Short.MAX_VALUE)
            .addGroup(ScrollPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(ScrollPnlLayout.createSequentialGroup()
                    .addComponent(ScrollDrawPad, javax.swing.GroupLayout.PREFERRED_SIZE, 656, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGap(0, 0, Short.MAX_VALUE)))
        );
        ScrollPnlLayout.setVerticalGroup(
            ScrollPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 526, Short.MAX_VALUE)
            .addGroup(ScrollPnlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addComponent(ScrollDrawPad, javax.swing.GroupLayout.PREFERRED_SIZE, 526, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(ToolsPnl, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(ScrollPnl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(DemoPnl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(ListPnl, javax.swing.GroupLayout.DEFAULT_SIZE, 227, Short.MAX_VALUE)
                .addGap(0, 0, 0))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(ToolsPnl, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 563, Short.MAX_VALUE)
            .addComponent(ListPnl, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 563, Short.MAX_VALUE)
            .addGroup(layout.createSequentialGroup()
                .addComponent(ScrollPnl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(DemoPnl, javax.swing.GroupLayout.PREFERRED_SIZE, 30, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    public void initComponentsVol2() {
        /* <---- Initialize GUI ----> */
        setLocationRelativeTo(null);
        ToolColorLbl.setBackground(toolColor);
        ToolColorLbl.setOpaque(true);
        BackgroundColorLbl.setBackground(backColor);
        BackgroundColorLbl.setOpaque(true);
        FillColorLbl.setBackground(fillColor);
        FillColorLbl.setOpaque(true);
        FillColorCmbBx.setEnabled(false);
        UpBtn.setEnabled(false);
        DownBtn.setEnabled(false);
        EditBtn.setEnabled(false);
        DeleteBtn.setEnabled(false);
        /* <---- Till here ----> */
        
        /* <---- ToolTip Texts ----> */
        PencilBtn.setToolTipText("Click and drag the mouse on the Draw Pad to draw abstract shapes.");
        LineBtn.setToolTipText("Click on two points on the Draw Pad to draw a line.");
        CircleBtn.setToolTipText("Click on two points(Center, Radius) on the Draw Pad to draw a circle.");
        TriangleBtn.setToolTipText("Click on three points(Starting, Middle, Ending point) on the DrawPad to draw a triangle.");
        SquareBtn.setToolTipText("Click on two points(Center, Side point) on the DrawPad to draw a square.");
        PolygonCmbBx.setToolTipText("Choose a shape and click on four (Polygon4) or five (Polygon5) points(Starting, Middle, Ending points) on the DrawPad to draw a polygon.");
        CrookedLineBtn.setToolTipText("Click on three points(Starting, Middle, Ending point) on the DrawPad to draw a crooked line.");
        RectangularBtn.setToolTipText("Click on two points(Top left, Bottom right point) on the DrawPad to draw a rectangular.");
        ToolColorBtn.setToolTipText("Click to choose the drawing tool's color.");
        BackgroundColorBtn.setToolTipText("Click to choose background's color.");
        FillColorCmbBx.setToolTipText("Click to choose a fill color or keep the shape uncolored.");
        StrokeSldr.setToolTipText("Drag to choose the size of stroke. Current stroke size: " + StrokeSldr.getValue());
        ResizeBtn.setToolTipText("Click to resize the Draw Pad.");
        ClearBtn.setToolTipText("Click to clear the Draw Pad.");
        UpBtn.setToolTipText("Click to scale up a shape in Draw Pad(Visually scale down in the list).");
        DownBtn.setToolTipText("Click to scale down a shape in Draw Pad(Visually scale up in the list).");
        EditBtn.setToolTipText("Edit currently chosen shape from the list(if none is chosen or exists, the button is disabled).");
        DeleteBtn.setToolTipText("Delete currently chosen shape from the list(if none is chosen or exists, the button is disabled).");
        RefreshBtn.setToolTipText("Click to refresh the content of Draw Pad(Re-draw every item of the list).");
        /* <---- Till here ----> */
        
        /* <---- Initialization of helping variables ----> */
        shapesX = new int[5];           // Allocate memory for 
        shapesY = new int[5];           // 5 integers per array
        
        minY = new int[5];
        maxY = new int[5]; 
        valueX = new double[5];
        slope = new double[5];
        
        for (int i = 0; i < 5; i++) {   // Initialization of the coordinates helping arrays and the filling methods helping arrays
            shapesX[i] = -1;
            shapesY[i] = -1;
            
            minY[i] = -1; 
            maxY[i] = -1;
            valueX[i] = -1;
            slope[i] = -1;
        }
        
        ShapesLst.setModel(ShapesListModel);
        /* <---- Till here ----> */
    }
    
    /* <---- Till here ----> */
    
    private void ResizeBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ResizeBtnActionPerformed
        SetDimensions();
        CoordinatesLbl.setText("Coordinates X, Y : (0,0)");
        ClearDrawPad();
        DrawAll();
        
    }//GEN-LAST:event_ResizeBtnActionPerformed

    private void ToolColorBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ToolColorBtnActionPerformed
        toolColor = JColorChooser.showDialog(null, "Tool Color", toolColor);
        ToolColorLbl.setBackground(toolColor);
        mouseClickCounter = 0;
    }//GEN-LAST:event_ToolColorBtnActionPerformed

    private void BackgroundColorBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_BackgroundColorBtnActionPerformed
        backColor = JColorChooser.showDialog(null, "BackGround Color", backColor);
        if (backColor != null) {
            DrawPad.setBackground(backColor);
            BackgroundColorLbl.setBackground(backColor);
        }
        mouseClickCounter = 0;
        ClearDrawPad();
        DrawAll();
    }//GEN-LAST:event_BackgroundColorBtnActionPerformed

    private void DrawPadMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_DrawPadMouseClicked
        if (drawMode != 0) {
            mouseClickCounter++;
        }
        
        switch(drawMode) {
            case 0:
                int x = evt.getX();
                int y = evt.getY();
                DrawPixel(x, y, toolColor, strokeSize);
                break;
            case 1:
                switch(mouseClickCounter) {
                    case 1:
                        shapesX[0] = evt.getX();
                        shapesY[0] = evt.getY();
                        DrawPixel(shapesX[0], shapesY[0], toolColor, strokeSize);
                        break;
                    case 2:
                        shapesX[1] = evt.getX();
                        shapesY[1] = evt.getY();
                        DrawPixel(shapesX[1], shapesY[1], toolColor, strokeSize);
                        DrawLine(shapesX[0], shapesY[0], shapesX[1], shapesY[1], toolColor, strokeSize);    // Draw the line
                        mouseClickCounter = 0;      // Re-initialization of the counter
                        
                        /* Editing the lists */
                        ArrayList<Integer> DetailsList = new ArrayList<>();
                        DetailsList.add(drawMode);
                        DetailsList.add(shapesX[0]);
                        DetailsList.add(shapesY[0]);
                        DetailsList.add(shapesX[1]);
                        DetailsList.add(shapesY[1]);
                        DetailsList.add(toolColor.getRed());
                        DetailsList.add(toolColor.getGreen());
                        DetailsList.add(toolColor.getBlue());
                        DetailsList.add(strokeSize);
                        ListOfDetailsLists.add(DetailsList);
                        ShapesListModel.addElement("Line");
                        /* Till here */
                        
                        for (int i = 0; i < 2; i++) {   // Re-initialization of shapesX and shapesY arrays
                            shapesX[i] = -1;
                            shapesY[i] = -1;
                        }
                        break;
                }
                break;
            case 2:
                switch(mouseClickCounter) {
                    case 1:
                        shapesX[0] = evt.getX();
                        shapesY[0] = evt.getY();
                        DrawPixel(shapesX[0], shapesY[0], toolColor, strokeSize);
                        break;
                    case 2:
                        shapesX[1] = evt.getX();
                        shapesY[1] = evt.getY();
                        DrawPixel(shapesX[1], shapesY[1], toolColor, strokeSize);
                        int radius = DrawCircle(shapesX[0], shapesY[0], shapesX[1], shapesY[1], toolColor, strokeSize);  // Draw the Circle
                        
                        if (filled) {
                            FillCircle(shapesX[0], shapesY[0], shapesX[1], shapesY[1], radius, toolColor, fillColor, strokeSize);
                        } else {
                            DrawPixel(shapesX[0], shapesY[0], backColor, strokeSize);
                        }
                        
                        mouseClickCounter = 0;      // Re-initialization of the counter
                        
                        /* Editing the lists */
                        ArrayList<Integer> DetailsList = new ArrayList<>();
                        DetailsList.add(drawMode);
                        DetailsList.add(shapesX[0]);
                        DetailsList.add(shapesY[0]);
                        DetailsList.add(radius);
                        DetailsList.add(toolColor.getRed());
                        DetailsList.add(toolColor.getGreen());
                        DetailsList.add(toolColor.getBlue());
                        DetailsList.add(strokeSize);
                        if (filled) {
                            DetailsList.add(1);
                            DetailsList.add(fillColor.getRed());
                            DetailsList.add(fillColor.getGreen());
                            DetailsList.add(fillColor.getBlue());
                        } else {
                            DetailsList.add(0);
                        }
                        ListOfDetailsLists.add(DetailsList);
                        ShapesListModel.addElement("Circle");
                        /* Till here */
                        
                        for (int i = 0; i < 2; i++) {   // Re-initialization of shapesX and shapesY arrays
                            shapesX[i] = -1;
                            shapesY[i] = -1;
                        }
                        break;
                }
                break;
            case 3:
                switch(mouseClickCounter) {
                    case 1:
                        shapesX[0] = evt.getX();
                        shapesY[0] = evt.getY();
                        DrawPixel(shapesX[0], shapesY[0], toolColor, strokeSize);
                        break;
                    case 2:
                        shapesX[1] = evt.getX();
                        shapesY[1] = evt.getY();
                        DrawPixel(shapesX[1], shapesY[1], toolColor, strokeSize);
                        break;
                    case 3:
                        shapesX[2] = evt.getX();
                        shapesY[2] = evt.getY();
                        DrawPixel(shapesX[2], shapesY[2], toolColor, strokeSize);
                        DrawTriangle(shapesX[0], shapesY[0], shapesX[1], shapesY[1], shapesX[2], shapesY[2], toolColor, strokeSize);
                        if (filled) {
                            FillTriangle(shapesX, shapesY, fillColor, strokeSize);
                        }
                        mouseClickCounter = 0;
                        
                        /* Editing the lists */
                        ArrayList<Integer> DetailsList = new ArrayList<>();
                        DetailsList.add(drawMode);
                        DetailsList.add(shapesX[0]);
                        DetailsList.add(shapesY[0]);
                        DetailsList.add(shapesX[1]);
                        DetailsList.add(shapesY[1]);
                        DetailsList.add(shapesX[2]);
                        DetailsList.add(shapesY[2]);
                        DetailsList.add(toolColor.getRed());
                        DetailsList.add(toolColor.getGreen());
                        DetailsList.add(toolColor.getBlue());
                        DetailsList.add(strokeSize);
                        if (filled) {
                            DetailsList.add(1);
                            DetailsList.add(fillColor.getRed());
                            DetailsList.add(fillColor.getGreen());
                            DetailsList.add(fillColor.getBlue());
                        } else {
                            DetailsList.add(0);
                        }
                        ListOfDetailsLists.add(DetailsList);
                        ShapesListModel.addElement("Triangle");
                        /* Till here */
                        
                        for (int i = 0; i < 3; i++) {
                            shapesX[i] = -1;
                            shapesY[i] = -1;
                        }
                    break;
                }
                break;
            case 4:
                switch(mouseClickCounter) {
                    case 1:
                        shapesX[0] = evt.getX();
                        shapesY[0] = evt.getY();
                        DrawPixel(shapesX[0], shapesY[0], toolColor, strokeSize);
                        break;
                    case 2:
                        shapesX[1] = evt.getX();
                        shapesY[1] = evt.getY();
                        DrawPixel(shapesX[1], shapesY[1], toolColor, strokeSize);
                        int side_distance = DrawSquare(shapesX[0], shapesY[0], shapesX[1], shapesY[1], toolColor, strokeSize);
                        DrawPixel(shapesX[0], shapesY[0], backColor, strokeSize);
                        if (filled) {
                            FillSquare(shapesX[0], shapesY[0], side_distance, fillColor, strokeSize);
                        }
                        mouseClickCounter = 0;
                        
                        /* Editing the lists */
                        ArrayList<Integer> DetailsList = new ArrayList<>();
                        DetailsList.add(drawMode);
                        DetailsList.add(shapesX[0]);
                        DetailsList.add(shapesY[0]);
                        DetailsList.add(side_distance);
                        DetailsList.add(toolColor.getRed());
                        DetailsList.add(toolColor.getGreen());
                        DetailsList.add(toolColor.getBlue());
                        DetailsList.add(strokeSize);
                        if (filled) {
                            DetailsList.add(1);
                            DetailsList.add(fillColor.getRed());
                            DetailsList.add(fillColor.getGreen());
                            DetailsList.add(fillColor.getBlue());
                        } else {
                            DetailsList.add(0);
                        }
                        ListOfDetailsLists.add(DetailsList);
                        ShapesListModel.addElement("Square");
                        /* Till here */
                        
                        for (int i = 0; i < 2; i++) {
                            shapesX[i] = -1;
                            shapesY[i] = -1;
                        }
                        break;
                }
                break;
            case 5:
                switch(mouseClickCounter) {
                    case 1:
                        shapesX[0] = evt.getX();
                        shapesY[0] = evt.getY();
                        DrawPixel(shapesX[0], shapesY[0], toolColor, strokeSize);
                        break;
                    case 2:
                        shapesX[1] = evt.getX();
                        shapesY[1] = evt.getY();
                        DrawPixel(shapesX[1], shapesY[1], toolColor, strokeSize);
                        break;
                    case 3:
                        shapesX[2] = evt.getX();
                        shapesY[2] = evt.getY();
                        DrawPixel(shapesX[2], shapesY[2], toolColor, strokeSize);
                        break;
                    case 4:
                        shapesX[3] = evt.getX();
                        shapesY[3] = evt.getY();
                        DrawPixel(shapesX[3], shapesY[3], toolColor, strokeSize);
                        DrawPolygon4(shapesX[0], shapesY[0], shapesX[1], shapesY[1], shapesX[2], shapesY[2], shapesX[3], shapesY[3], toolColor, strokeSize);
                        if (filled) {
                            FillPolygon4(shapesX, shapesY, fillColor, strokeSize);
                        }
                        mouseClickCounter = 0;
                        
                        /* Editing the lists */
                        ArrayList<Integer> DetailsList = new ArrayList<>();
                        DetailsList.add(drawMode);
                        DetailsList.add(shapesX[0]);
                        DetailsList.add(shapesY[0]);
                        DetailsList.add(shapesX[1]);
                        DetailsList.add(shapesY[1]);
                        DetailsList.add(shapesX[2]);
                        DetailsList.add(shapesY[2]);
                        DetailsList.add(shapesX[3]);
                        DetailsList.add(shapesY[3]);
                        DetailsList.add(toolColor.getRed());
                        DetailsList.add(toolColor.getGreen());
                        DetailsList.add(toolColor.getBlue());
                        DetailsList.add(strokeSize);
                        if (filled) {
                            DetailsList.add(1);
                            DetailsList.add(fillColor.getRed());
                            DetailsList.add(fillColor.getGreen());
                            DetailsList.add(fillColor.getBlue());
                        } else {
                            DetailsList.add(0);
                        }
                        ListOfDetailsLists.add(DetailsList);
                        ShapesListModel.addElement("Polygon (4 sides)");
                        /* Till here */
                        
                        for (int i = 0; i < 4; i++) {
                            shapesX[i] = -1;
                            shapesY[i] = -1;
                        }
                        break;
                }
                break;
            case 6:
                switch(mouseClickCounter) {
                    case 1:
                        shapesX[0] = evt.getX();
                        shapesY[0] = evt.getY();
                        DrawPixel(shapesX[0], shapesY[0], toolColor, strokeSize);
                        break;
                    case 2:
                        shapesX[1] = evt.getX();
                        shapesY[1] = evt.getY();
                        DrawPixel(shapesX[1], shapesY[1], toolColor, strokeSize);
                        break;
                    case 3:
                        shapesX[2] = evt.getX();
                        shapesY[2] = evt.getY();
                        DrawPixel(shapesX[2], shapesY[2], toolColor, strokeSize);
                        break;
                    case 4:
                        shapesX[3] = evt.getX();
                        shapesY[3] = evt.getY();
                        DrawPixel(shapesX[3], shapesY[3], toolColor, strokeSize);
                        break;
                    case 5:
                        shapesX[4] = evt.getX();
                        shapesY[4] = evt.getY();
                        DrawPixel(shapesX[4], shapesY[4], toolColor, strokeSize);
                        DrawPolygon5(shapesX[0], shapesY[0], shapesX[1], shapesY[1], shapesX[2], shapesY[2], shapesX[3], shapesY[3], shapesX[4], shapesY[4], toolColor, strokeSize);
                        if (filled) {
                            FillPolygon5(shapesX, shapesY, fillColor, strokeSize);
                        }
                        mouseClickCounter = 0;
                        
                        /* Editing the lists */
                        ArrayList<Integer> DetailsList = new ArrayList<>();
                        DetailsList.add(drawMode);
                        DetailsList.add(shapesX[0]);
                        DetailsList.add(shapesY[0]);
                        DetailsList.add(shapesX[1]);
                        DetailsList.add(shapesY[1]);
                        DetailsList.add(shapesX[2]);
                        DetailsList.add(shapesY[2]);
                        DetailsList.add(shapesX[3]);
                        DetailsList.add(shapesY[3]);
                        DetailsList.add(shapesX[4]);
                        DetailsList.add(shapesY[4]);
                        DetailsList.add(toolColor.getRed());
                        DetailsList.add(toolColor.getGreen());
                        DetailsList.add(toolColor.getBlue());
                        DetailsList.add(strokeSize);
                        if (filled) {
                            DetailsList.add(1);
                            DetailsList.add(fillColor.getRed());
                            DetailsList.add(fillColor.getGreen());
                            DetailsList.add(fillColor.getBlue());
                        } else {
                            DetailsList.add(0);
                        }
                        ListOfDetailsLists.add(DetailsList);
                        ShapesListModel.addElement("Polygon (5 sides)");
                        /* Till here */
                        
                        for (int i = 0; i < 5; i++) {
                            shapesX[i] = -1;
                            shapesY[i] = -1;
                        }
                        break;
                }
                break;
            case 7:
                switch(mouseClickCounter) {
                    case 1:
                        shapesX[0] = evt.getX();
                        shapesY[0] = evt.getY();
                        DrawPixel(shapesX[0], shapesY[0], toolColor, strokeSize);
                        break;
                    case 2:
                        shapesX[1] = evt.getX();
                        shapesY[1] = evt.getY();
                        DrawPixel(shapesX[1], shapesY[1], toolColor, strokeSize);
                        break;
                    case 3:
                        shapesX[2] = evt.getX();
                        shapesY[2] = evt.getY();
                        DrawPixel(shapesX[2], shapesY[2], toolColor, strokeSize);
                        DrawCrookedLine(shapesX[0], shapesY[0], shapesX[1], shapesY[1], shapesX[2], shapesY[2], toolColor, strokeSize);
                        mouseClickCounter = 0;
                        
                        /* Editing the lists */
                        ArrayList<Integer> DetailsList = new ArrayList<>();
                        DetailsList.add(drawMode);
                        DetailsList.add(shapesX[0]);
                        DetailsList.add(shapesY[0]);
                        DetailsList.add(shapesX[1]);
                        DetailsList.add(shapesY[1]);
                        DetailsList.add(shapesX[2]);
                        DetailsList.add(shapesY[2]);
                        DetailsList.add(toolColor.getRed());
                        DetailsList.add(toolColor.getGreen());
                        DetailsList.add(toolColor.getBlue());
                        DetailsList.add(strokeSize);
                        ListOfDetailsLists.add(DetailsList);
                        ShapesListModel.addElement("Crooked Line");
                        /* Till here */
                        
                        for (int i = 0; i < 3; i++) {
                            shapesX[i] = -1;
                            shapesY[i] = -1;
                        }
                    break;
                }
                break;
            case 8:
                switch(mouseClickCounter) {
                    case 1:
                        shapesX[0] = evt.getX();
                        shapesY[0] = evt.getY();
                        DrawPixel(shapesX[0], shapesY[0], toolColor, strokeSize);
                        break;
                    case 2:
                        shapesX[1] = evt.getX();
                        shapesY[1] = evt.getY();
                        DrawPixel(shapesX[1], shapesY[1], toolColor, strokeSize);
                        int[] dimensions = DrawRectangular(shapesX[0], shapesY[0], shapesX[1], shapesY[1], toolColor, strokeSize);
                        if (filled) {
                            FillRectangular(shapesX[0], shapesY[0], shapesX[1], shapesY[1], fillColor, strokeSize);
                        }
                        mouseClickCounter = 0;
                        
                        /* Editing the lists */
                        ArrayList<Integer> DetailsList = new ArrayList<>();
                        DetailsList.add(drawMode);
                        DetailsList.add(shapesX[0]);
                        DetailsList.add(shapesY[0]);
                        DetailsList.add(shapesX[1]);
                        DetailsList.add(shapesY[1]);
                        DetailsList.add(dimensions[0]);
                        DetailsList.add(dimensions[1]);
                        DetailsList.add(toolColor.getRed());
                        DetailsList.add(toolColor.getGreen());
                        DetailsList.add(toolColor.getBlue());
                        DetailsList.add(strokeSize);
                        if (filled) {
                            DetailsList.add(1);
                            DetailsList.add(fillColor.getRed());
                            DetailsList.add(fillColor.getGreen());
                            DetailsList.add(fillColor.getBlue());
                        } else {
                            DetailsList.add(0);
                        }
                        ListOfDetailsLists.add(DetailsList);
                        ShapesListModel.addElement("Rectangular");
                        /* Till here */
                        
                        for (int i = 0; i < 2; i++) {
                            shapesX[i] = -1;
                            shapesY[i] = -1;
                        }
                        break;
                }
                break;
        }
    }//GEN-LAST:event_DrawPadMouseClicked

    private void DrawPadMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_DrawPadMouseDragged
        if (drawMode == 0) {
            int x = evt.getX();
            int y = evt.getY();
            DrawPixel(x, y, toolColor, strokeSize);
        }
    }//GEN-LAST:event_DrawPadMouseDragged

    private void DrawPadMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_DrawPadMouseMoved
        CoordinatesLbl.setText("Coordinates X, Y : " + "(" + evt.getX() + "," + evt.getY() + ")");
    }//GEN-LAST:event_DrawPadMouseMoved

    private void LineBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_LineBtnActionPerformed
        drawMode = 1;
        mouseClickCounter = 0;
        FillColorCmbBx.setSelectedIndex(0);
        filled = false;
        FillColorCmbBx.setEnabled(false);
    }//GEN-LAST:event_LineBtnActionPerformed

    private void CircleBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CircleBtnActionPerformed
        drawMode = 2;
        mouseClickCounter = 0;
        FillColorCmbBx.setEnabled(true);
    }//GEN-LAST:event_CircleBtnActionPerformed

    private void TriangleBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_TriangleBtnActionPerformed
        drawMode = 3;
        mouseClickCounter = 0;
        FillColorCmbBx.setEnabled(true);
    }//GEN-LAST:event_TriangleBtnActionPerformed

    private void SquareBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SquareBtnActionPerformed
        drawMode = 4;
        mouseClickCounter = 0;
        FillColorCmbBx.setEnabled(true);
    }//GEN-LAST:event_SquareBtnActionPerformed

    private void PencilBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PencilBtnActionPerformed
        drawMode = 0;
        mouseClickCounter = 0;
        FillColorCmbBx.setSelectedIndex(0);
        filled = false;
        FillColorCmbBx.setEnabled(false);
    }//GEN-LAST:event_PencilBtnActionPerformed

    private void CrookedLineBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CrookedLineBtnActionPerformed
        drawMode = 7;
        mouseClickCounter = 0;
        FillColorCmbBx.setSelectedIndex(0);
        filled = false;
        FillColorCmbBx.setEnabled(false);
    }//GEN-LAST:event_CrookedLineBtnActionPerformed

    private void RectangularBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RectangularBtnActionPerformed
        drawMode = 8;
        mouseClickCounter = 0;
        FillColorCmbBx.setEnabled(true);
    }//GEN-LAST:event_RectangularBtnActionPerformed

    private void PolygonCmbBxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PolygonCmbBxActionPerformed
        if (PolygonCmbBx.getSelectedIndex() == 0) {
            drawMode = 5;
        } else if(PolygonCmbBx.getSelectedIndex() == 1) {
            drawMode = 6;
        }
        mouseClickCounter = 0;
        FillColorCmbBx.setEnabled(true);
    }//GEN-LAST:event_PolygonCmbBxActionPerformed

    private void ClearBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ClearBtnActionPerformed
        String QuestionMsg = "If you choose to clear the Draw Pad, any shape drawn will be deleted. Do you want to continue?";
        int yes_no = JOptionPane.showConfirmDialog(null, QuestionMsg, "Clear Draw Pad", JOptionPane.YES_NO_OPTION);
        if (yes_no == JOptionPane.YES_OPTION) {
            int Size = ShapesListModel.getSize();
            for (int i = Size - 1; i >= 0; i--) {
                ShapesListModel.remove(i);
                ListOfDetailsLists.remove(i);
                DetailsTxtr.setText("");
            }
            ClearDrawPad();
        }
    }//GEN-LAST:event_ClearBtnActionPerformed

    private void ShapesLstValueChanged(javax.swing.event.ListSelectionEvent evt) {//GEN-FIRST:event_ShapesLstValueChanged
        if(ShapesLst.getSelectedValue() != null) {
            ArrayList<Integer> DetailsList = new ArrayList<>();
            PrintDetails(DetailsList);
            UpBtn.setEnabled(true);
            DownBtn.setEnabled(true);
            EditBtn.setEnabled(true);
            DeleteBtn.setEnabled(true);
        } else {
            UpBtn.setEnabled(false);
            DownBtn.setEnabled(false);
            EditBtn.setEnabled(false);
            DeleteBtn.setEnabled(false);
        }
    }//GEN-LAST:event_ShapesLstValueChanged

    private void UpBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_UpBtnActionPerformed
        int selectedIndex = ShapesLst.getSelectedIndex();
        SwapListElements(selectedIndex, true);
        ShapesLst.setSelectedIndex(selectedIndex + 1);
        ClearDrawPad();
        DrawAll();
    }//GEN-LAST:event_UpBtnActionPerformed

    private void DownBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_DownBtnActionPerformed
        int selectedIndex = ShapesLst.getSelectedIndex();
        SwapListElements(selectedIndex, false);
        ShapesLst.setSelectedIndex(selectedIndex - 1);
        ClearDrawPad();
        DrawAll();
    }//GEN-LAST:event_DownBtnActionPerformed

    private void EditBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_EditBtnActionPerformed
        int selectedIndex = ShapesLst.getSelectedIndex();
        ArrayList<Integer> DetailsList = ListOfDetailsLists.get(selectedIndex);
        
        EditDialog EDialog = new EditDialog(this, true, DetailsList);
        EDialog.setVisible(true);
        //EDialog.HelpingList = DetailsList;
        ListOfDetailsLists.set(selectedIndex, DetailsList);
        PrintDetails(DetailsList);
        ClearDrawPad();
        DrawAll();
    }//GEN-LAST:event_EditBtnActionPerformed

    private void DeleteBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_DeleteBtnActionPerformed
        int selectedIndex = ShapesLst.getSelectedIndex();
        String MyObject = (String) ShapesLst.getSelectedValue();
        int Size = ShapesListModel.getSize(); 
        if (selectedIndex >= 0 && MyObject != null && Size > 0) {
            ShapesListModel.removeElementAt(selectedIndex);
            ListOfDetailsLists.remove(selectedIndex);
            DetailsTxtr.setText("");
        }
        ShapesListModel.removeElement(ShapesLst.getSelectedValue());
        ClearDrawPad();
        DrawAll();
    }//GEN-LAST:event_DeleteBtnActionPerformed

    private void StrokeSldrStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_StrokeSldrStateChanged
        strokeSize = StrokeSldr.getValue();
        StrokeSldr.setToolTipText("Drag to choose the size of stroke. Current stroke size: " + strokeSize);
        mouseClickCounter = 0;
    }//GEN-LAST:event_StrokeSldrStateChanged

    private void FillColorCmbBxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_FillColorCmbBxActionPerformed
        if (FillColorCmbBx.getSelectedIndex() == 0) {
            filled = false;
        } else if (FillColorCmbBx.getSelectedIndex() == 1){
            filled = true;
            fillColor = JColorChooser.showDialog(null, "Fill Color", fillColor);
            FillColorLbl.setBackground(fillColor);
        }
        mouseClickCounter = 0;
    }//GEN-LAST:event_FillColorCmbBxActionPerformed

    private void RefreshBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RefreshBtnActionPerformed
        ClearDrawPad();
        DrawAll();
    }//GEN-LAST:event_RefreshBtnActionPerformed

    /* <---- Drawing functions (based on Bresenham algorithms) ----> */
    
    public void DrawPixel(int x, int y, Color toolColor, int strokeSize) {
        Graphics g = DrawPad.getGraphics();
        g.setColor(toolColor);
        g.fillRect(x, y, strokeSize, strokeSize);
    }
    
    public void DrawLine(int x1, int y1, int x2, int y2, Color toolColor, int strokeSize) {
        int w = x2 - x1;
        int h = y2 - y1;
        int dx1 = 0, dy1 = 0, dx2 = 0, dy2 = 0 ;
        if (w < 0) dx1 = -1 ; else if (w > 0) dx1 = 1 ;
        if (h < 0) dy1 = -1 ; else if (h > 0) dy1 = 1 ;
        if (w < 0) dx2 = -1 ; else if (w > 0) dx2 = 1 ;
        int longest = Math.abs(w) ;
        int shortest = Math.abs(h) ;
        
        if (!(longest > shortest)) {
            longest = Math.abs(h) ;
            shortest = Math.abs(w) ;
            if (h < 0) dy2 = -1 ; else if (h > 0) dy2 = 1 ;
            dx2 = 0 ;            
        }
        
        int numerator = longest >> 1 ;
        for (int i = 0; i <= longest; i++) {
            DrawPixel(x1, y1, toolColor, strokeSize);
            numerator += shortest ;
            if (!(numerator < longest)) {
                numerator -= longest ;
                x1 += dx1;
                y1 += dy1;
            } else {
                x1 += dx2;
                y1 += dy2;
            }
        }
    }
    
    public int DrawCircle(int x1, int y1, int x2, int y2, Color toolColor, int strokeSize) {
        int radius = (int) Math.sqrt((Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)));  // calculate radius of circle  

        int discriminant = (5 - radius << 2) >> 2 ;
        int i = 0, j = radius ;
        while (i <= j) {
            DrawPixel(x1 + i, y1 - j, toolColor, strokeSize);
            DrawPixel(x1 + j, y1 - i, toolColor, strokeSize);
            DrawPixel(x1 + i, y1 + j, toolColor, strokeSize);
            DrawPixel(x1 + j, y1 + i, toolColor, strokeSize);
            DrawPixel(x1 - i, y1 - j, toolColor, strokeSize);
            DrawPixel(x1 - j, y1 - i, toolColor, strokeSize);
            DrawPixel(x1 - i, y1 + j, toolColor, strokeSize);
            DrawPixel(x1 - j, y1 + i, toolColor, strokeSize);
            i++;
            if (discriminant < 0) {                
                discriminant += (i << 1) + 1 ;
            } else {
                j-- ;
                discriminant += (1 + i - j) << 1 ;
            }
        }
        return radius;
    }
    
    public void DrawTriangle(int x1, int y1, int x2, int y2, int x3, int y3, Color toolColor, int strokeSize) {
        DrawLine(x1, y1, x2, y2, toolColor, strokeSize);
        DrawLine(x2, y2, x3, y3, toolColor, strokeSize);
        DrawLine(x3, y3, x1, y1, toolColor, strokeSize);
    }
    
    public int DrawSquare(int x1, int y1, int x2, int y2, Color toolColor, int strokeSize) {
        int deltax = Math.abs(x1 - x2);
        int deltay = Math.abs(y1 - y2);
        int side_distance;
        if (deltax >= deltay) {
            DrawCrookedLine(x1 - deltax, y1 + deltax, x1 + deltax, y1 + deltax, x1 + deltax, y1 - deltax, toolColor, strokeSize);
            DrawCrookedLine(x1 + deltax, y1 - deltax, x1 - deltax, y1 - deltax, x1 - deltax, y1 + deltax, toolColor, strokeSize);
            side_distance = 2 * deltax;
        } else {
            DrawCrookedLine(x1 - deltay, y1 + deltay, x1 + deltay, y1 + deltay, x1 + deltay, y1 - deltay, toolColor, strokeSize);
            DrawCrookedLine(x1 + deltay, y1 - deltay, x1 - deltay, y1 - deltay, x1 - deltay, y1 + deltay, toolColor, strokeSize);
            side_distance = 2 * deltay;
        }
        return side_distance;
    }
    
    public void DrawPolygon4(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, Color toolColor, int strokeSize) {
        DrawLine(x1, y1, x2, y2, toolColor, strokeSize);
        DrawLine(x2, y2, x3, y3, toolColor, strokeSize);
        DrawLine(x3, y3, x4, y4, toolColor, strokeSize);
        DrawLine(x4, y4, x1, y1, toolColor, strokeSize);
    }
    
    public void DrawPolygon5(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, int x5, int y5, Color toolColor, int strokeSize) {
        DrawLine(x1, y1, x2, y2, toolColor, strokeSize);
        DrawLine(x2, y2, x3, y3, toolColor, strokeSize);
        DrawLine(x3, y3, x4, y4, toolColor, strokeSize);
        DrawLine(x4, y4, x5, y5, toolColor, strokeSize);
        DrawLine(x5, y5, x1, y1, toolColor, strokeSize);
    }
    
    public void DrawCrookedLine(int x1, int y1, int x2, int y2, int x3, int y3, Color toolColor, int strokeSize) {
        DrawLine(x1, y1, x2, y2, toolColor, strokeSize);
        DrawLine(x2, y2, x3, y3, toolColor, strokeSize);
    }
    
    public int[] DrawRectangular(int x1, int y1, int x2, int y2, Color toolColor, int strokeSize) {
        DrawLine(x1, y1, x1, y2, toolColor, strokeSize);
        DrawLine(x1, y1, x2, y1, toolColor, strokeSize);
        DrawLine(x1, y2, x2, y2, toolColor, strokeSize);
        DrawLine(x2, y1, x2, y2, toolColor, strokeSize);
        int[] dimensions = new int[2];
        int deltax = Math.abs(x1 - x2);
        int deltay = Math.abs(y1 - y2);
        
        dimensions[0] = deltax;
        dimensions[1] = deltay;
        return dimensions;
    }
    
    public void DrawAll() {
        Color shapeToolColor;
        int EndPointX, EndPointY;
        for (ArrayList<Integer> DetailsList : ListOfDetailsLists) {
            switch(DetailsList.get(0)) {
                case 1:
                    shapeToolColor = new Color(DetailsList.get(5), DetailsList.get(6), DetailsList.get(7));
                    DrawLine(DetailsList.get(1), DetailsList.get(2), DetailsList.get(3), DetailsList.get(4), shapeToolColor, DetailsList.get(8));
                    break;
                case 2:
                    shapeToolColor = new Color(DetailsList.get(4), DetailsList.get(5), DetailsList.get(6));
                    EndPointX = DetailsList.get(1) + DetailsList.get(3);
                    EndPointY = DetailsList.get(2);
                    DrawCircle(DetailsList.get(1), DetailsList.get(2), EndPointX, EndPointY, shapeToolColor, DetailsList.get(7));
                    if (DetailsList.get(8) == 1) {
                        Color shapeFillColor = new Color(DetailsList.get(9), DetailsList.get(10), DetailsList.get(11));
                        FillCircle(DetailsList.get(1), DetailsList.get(2), EndPointX, EndPointY, DetailsList.get(3), shapeToolColor, shapeFillColor, DetailsList.get(7));
                    }
                    break;
                case 3:
                    shapeToolColor = new Color(DetailsList.get(7), DetailsList.get(8), DetailsList.get(9));
                    DrawTriangle(DetailsList.get(1), DetailsList.get(2), DetailsList.get(3), DetailsList.get(4), DetailsList.get(5), DetailsList.get(6), shapeToolColor, DetailsList.get(10));
                    if (DetailsList.get(11) == 1) {
                        Color shapeFillColor = new Color(DetailsList.get(12), DetailsList.get(13), DetailsList.get(14));
                        int[] Xs = {DetailsList.get(1), DetailsList.get(3), DetailsList.get(5)};
                        int[] Ys = {DetailsList.get(2), DetailsList.get(4), DetailsList.get(6)};
                        FillTriangle(Xs, Ys, shapeFillColor, DetailsList.get(10));
                    }
                    break;
                case 4:
                    shapeToolColor = new Color(DetailsList.get(4), DetailsList.get(5), DetailsList.get(6));
                    EndPointX = DetailsList.get(1) + DetailsList.get(3)/2;
                    EndPointY = DetailsList.get(2);
                    DrawSquare(DetailsList.get(1), DetailsList.get(2), EndPointX, EndPointY, shapeToolColor, DetailsList.get(7));
                    if (DetailsList.get(8) == 1) {
                        Color shapeFillColor = new Color(DetailsList.get(9), DetailsList.get(10), DetailsList.get(11));
                        FillSquare(DetailsList.get(1), DetailsList.get(2), DetailsList.get(3), shapeFillColor, DetailsList.get(7));
                    }
                    break;
                case 5:
                    shapeToolColor = new Color(DetailsList.get(9), DetailsList.get(10), DetailsList.get(11));
                    DrawPolygon4(DetailsList.get(1), DetailsList.get(2), DetailsList.get(3), DetailsList.get(4), DetailsList.get(5), DetailsList.get(6), DetailsList.get(7), DetailsList.get(8), shapeToolColor, DetailsList.get(12));
                    if (DetailsList.get(13) == 1) {
                        Color shapeFillColor = new Color(DetailsList.get(14), DetailsList.get(15), DetailsList.get(16));
                        int[] Xs = {DetailsList.get(1), DetailsList.get(3), DetailsList.get(5), DetailsList.get(7)};
                        int[] Ys = {DetailsList.get(2), DetailsList.get(4), DetailsList.get(6), DetailsList.get(8)};
                        FillPolygon4(Xs, Ys, shapeFillColor, DetailsList.get(12));
                    }
                    break;
                case 6:
                    shapeToolColor = new Color(DetailsList.get(11), DetailsList.get(12), DetailsList.get(13));
                    DrawPolygon5(DetailsList.get(1), DetailsList.get(2), DetailsList.get(3), DetailsList.get(4), DetailsList.get(5), DetailsList.get(6), DetailsList.get(7), DetailsList.get(8), DetailsList.get(9), DetailsList.get(10), shapeToolColor, DetailsList.get(14));
                    if (DetailsList.get(15) == 1) {
                        Color shapeFillColor = new Color(DetailsList.get(16), DetailsList.get(17), DetailsList.get(18));
                        int[] Xs = {DetailsList.get(1), DetailsList.get(3), DetailsList.get(5), DetailsList.get(7), DetailsList.get(9)};
                        int[] Ys = {DetailsList.get(2), DetailsList.get(4), DetailsList.get(6), DetailsList.get(8), DetailsList.get(10)};
                        FillPolygon5(Xs, Ys, shapeFillColor, DetailsList.get(14));
                    }
                    break;
                case 7:
                    shapeToolColor = new Color(DetailsList.get(7), DetailsList.get(8), DetailsList.get(9));
                    DrawCrookedLine(DetailsList.get(1), DetailsList.get(2), DetailsList.get(3), DetailsList.get(4), DetailsList.get(5), DetailsList.get(6), shapeToolColor, DetailsList.get(10));
                    break;
                case 8:
                    shapeToolColor = new Color(DetailsList.get(7), DetailsList.get(8), DetailsList.get(9));
                    DrawRectangular(DetailsList.get(1), DetailsList.get(2), DetailsList.get(3), DetailsList.get(4), shapeToolColor, DetailsList.get(10));
                    if (DetailsList.get(11) == 1) {
                        Color shapeFillColor = new Color(DetailsList.get(12), DetailsList.get(13), DetailsList.get(14));
                        FillRectangular(DetailsList.get(1), DetailsList.get(2), DetailsList.get(3), DetailsList.get(4), shapeFillColor, DetailsList.get(10));
                    }
                    break;
            }
        }
    }
    
    /* <---- Till here ----> */ 
    
    /* <---- Filling functions ----> */
    
    public void FillCircle(int centerX, int centerY, int initialX, int initialY, int radius, Color toolColor, Color fillColor, int strokeSize) {
        int discriminant = (5 - radius << 2) >> 2 ;
        int i = 0, j = radius ;
        while (i <= j) {
            DrawLine(centerX - i, centerY - j, centerX + i, centerY - j, fillColor, 1);
            DrawLine(centerX - j, centerY - i, centerX + j, centerY - i, fillColor, 1);
            DrawLine(centerX - i, centerY + j, centerX + i, centerY + j, fillColor, 1);
            DrawLine(centerX - j, centerY + i, centerX + j, centerY + i, fillColor, 1);
            i++;
            if (discriminant < 0) {                
                discriminant += (i << 1) + 1 ;
            } else {
                j-- ;
                discriminant += (1 + i - j) << 1 ;
            }
        }
        DrawCircle(centerX, centerY, initialX, initialY, toolColor, strokeSize);
    }

    public void FillTriangle(int shapesX[], int shapesY[], Color fillColor, int strokeSize) {
        GetScanLines(shapesX, shapesY, 3);
        SortScanLines(minY, maxY, valueX, slope, 3);
        FillPolygon(shapesX, shapesY, 3, fillColor, strokeSize);
    }
    
    public void FillSquare(int centerX, int centerY, int side, Color fillColor, int strokeSize) {
        int[] pointsX = {centerX - side/2 + strokeSize, 0};
        if (strokeSize == 1) {
             pointsX[1] = centerX + side/2 - strokeSize;
        } else {
            pointsX[1] = centerX + side/2 - strokeSize/2;
        }
        
        int[] pointsY = {centerY - side/2 + strokeSize, centerY + side/2};
        
        if (pointsX[0] < 0) {
            pointsX[0] = 0;
        } 
        
        if (pointsX[1] > DrawPadWidth) {
            pointsX[1] = DrawPadWidth;
        }
        
        if (pointsY[0] < 0) {
            pointsY[0] = 0;
        } 
        
        if (pointsY[1] > DrawPadHeight) {
            pointsY[1] = DrawPadHeight;
        }
        
        for (int j = pointsY[0]; j < pointsY[1]; j++) {
            DrawLine(pointsX[0], j, pointsX[1], j, fillColor, 1);
        }
    }
    
    public void FillPolygon4(int shapesX[], int shapesY[], Color fillColor, int strokeSize) {
        GetScanLines(shapesX, shapesY, 4);
        SortScanLines(minY, maxY, valueX, slope, 4);
        FillPolygon(shapesX, shapesY, 4, fillColor, strokeSize);
    }
    
    public void FillPolygon5(int shapesX[], int shapesY[], Color fillColor, int strokeSize) {
        GetScanLines(shapesX, shapesY, 5);
        SortScanLines(minY, maxY, valueX, slope, 5);
        FillPolygon(shapesX, shapesY, 5, fillColor, strokeSize);
    }
    
    public void FillRectangular(int initialX, int initialY, int endingX, int endingY, Color fillColor, int strokeSize) {
        int[] pointsX = {initialX + strokeSize, 0};
        if (strokeSize == 1) {
             pointsX[1] = endingX - strokeSize;
        } else {
            pointsX[1] = endingX - strokeSize/2;
        }
        
        int[] pointsY = {initialY + strokeSize, endingY};
        
        if (pointsX[0] < 0) {
            pointsX[0] = 0;
        } 
        
        if (pointsX[1] > DrawPadWidth) {
            pointsX[1] = DrawPadWidth;
        }
        
        if (pointsY[0] < 0) {
            pointsY[0] = 0;
        } 
        
        if (pointsY[1] > DrawPadHeight) {
            pointsY[1] = DrawPadHeight;
        }
        
        for (int j = pointsY[0]; j < pointsY[1]; j++) {
            DrawLine(pointsX[0], j, pointsX[1], j, fillColor, 1);
        }
    }
    
    /* <---- Till here ----> */
    
    /* <---- Helping functions ----> */
    
    public void SetDimensions() {
        String InfoMsg = "The minimum values which Draw Pad's dimensions can get, are 650 x 520. Any lesser values will be automatically set to the default dimensions.";
        JOptionPane.showMessageDialog(null,InfoMsg);
        
        String firstNum, secondNum;
        
        firstNum = JOptionPane.showInputDialog("Please enter the Draw Pad's width."); 
        secondNum = JOptionPane.showInputDialog("Please enter the Draw Pad's height.");
        
        Pattern forbiddenchars = Pattern.compile("[A-Z,a-z,&%$#@!()*^]");
        Matcher mFirst = forbiddenchars.matcher(firstNum);
        Matcher mSecond = forbiddenchars.matcher(secondNum);
        
        while ((mFirst.find()) || (mSecond.find())) {
            JOptionPane.showMessageDialog(null, "Please enter only numbers.");
            
            firstNum = JOptionPane.showInputDialog("Please enter the Draw Pad's width."); 
            secondNum = JOptionPane.showInputDialog("Please enter the Draw Pad's height.");
            
            mFirst = forbiddenchars.matcher(firstNum);
            mSecond = forbiddenchars.matcher(secondNum);
        }
        
        DrawPadWidth = Integer.parseInt(firstNum);      // Convert string input (width) to integer
        DrawPadHeight = Integer.parseInt(secondNum);    // Convert string input (height) to integer
        
        if (DrawPadWidth < DrawPadMaxWidth) {
            DrawPadWidth = DrawPadMaxWidth;
        }
        
        if (DrawPadHeight < DrawPadMaxHeight) {
            DrawPadHeight = DrawPadMaxHeight;
        }
        
        DrawPad.setPreferredSize(new Dimension(DrawPadWidth, DrawPadHeight));   // Resize the 
        DrawPad.revalidate();                                                   // Draw Pad
    }
    
    public void SwapListElements(int position, boolean updown) {
        Object mySelectedObject = ShapesListModel.getElementAt(position);
        ArrayList<Integer> selectedList = ListOfDetailsLists.get(position);
        if (updown) {
            if (position < ShapesListModel.getSize() - 1) {
                Object highObject = ShapesListModel.getElementAt(position + 1);
                ShapesListModel.set(position, highObject);
                ShapesListModel.set(position + 1, mySelectedObject);
                /* Swap List of DetailsLists */
                ArrayList<Integer> swapList = ListOfDetailsLists.get(position + 1);
                ListOfDetailsLists.set(position + 1, selectedList);
                ListOfDetailsLists.set(position, swapList);
            } else {
                JOptionPane.showMessageDialog(null, "The selected item is the highest one!");
            }
        } else {
            if (position > 0) {
                Object highObject = ShapesListModel.getElementAt(position - 1);
                ShapesListModel.set(position, highObject);
                ShapesListModel.set(position - 1, mySelectedObject);
                /* Swap List of DetailsLists */
                ArrayList<Integer> swapList = ListOfDetailsLists.get(position - 1);
                ListOfDetailsLists.set(position - 1, selectedList);
                ListOfDetailsLists.set(position, swapList);
            } else {
                JOptionPane.showMessageDialog(null, "The selected item is the lowest one!");
            }
        }
    }
    
    public void PrintDetails(ArrayList<Integer> DetailsList) {
        int position = ShapesLst.getSelectedIndex();
        DetailsList = ListOfDetailsLists.get(position);
        int shapeMode = DetailsList.get(0);
        switch(shapeMode) {
                case 1:
                    DetailsTxtr.setText("Starting Point : (" + DetailsList.get(1) + "," + DetailsList.get(2) 
                            + ")\nEnding Point : (" + DetailsList.get(3) + "," + DetailsList.get(4) 
                            + ")\nTool Color : R(" + DetailsList.get(5) + ") G(" + DetailsList.get(6) + ") B(" + DetailsList.get(7)
                            + ")\nStroke Size : " + DetailsList.get(8));
                    break;
                case 2:
                    DetailsTxtr.setText("Center Point : (" + DetailsList.get(1) + "," + DetailsList.get(2) 
                            + ")\nRadius : " + DetailsList.get(3)  
                            + "\nTool Color : R(" + DetailsList.get(4) + ") G(" + DetailsList.get(5) + ") B(" + DetailsList.get(6) + ")");
                    if (DetailsList.get(8) == 1) {
                        DetailsTxtr.append("\nFill Color : R(" + DetailsList.get(9) + ") G(" + DetailsList.get(10) + ") B(" + DetailsList.get(11) + ")");
                    } else {
                        DetailsTxtr.append("\nFill Color : Unfilled");
                    }
                    DetailsTxtr.append("\nStroke Size : " + DetailsList.get(7));
                    break;
                case 3:
                    DetailsTxtr.setText("Starting Point : (" + DetailsList.get(1) + "," + DetailsList.get(2) 
                            + ")\nMiddle Point : (" + DetailsList.get(3) + "," + DetailsList.get(4)
                            + ")\nEnding Point : (" + DetailsList.get(5) + "," + DetailsList.get(6)
                            + ")\nTool Color : R(" + DetailsList.get(7) + ") G(" + DetailsList.get(8) + ") B(" + DetailsList.get(9) + ")");
                    if (DetailsList.get(11) == 1) {
                        DetailsTxtr.append("\nFill Color : R(" + DetailsList.get(12) + ") G(" + DetailsList.get(13) + ") B(" + DetailsList.get(14) + ")");
                    } else {
                        DetailsTxtr.append("\nFill Color : Unfilled");
                    }
                    DetailsTxtr.append("\nStroke Size : " + DetailsList.get(10));
                    break;
                case 4:
                    DetailsTxtr.setText("Center Point : (" + DetailsList.get(1) + "," + DetailsList.get(2) 
                            + ")\nSide Distance : " + DetailsList.get(3)  
                            + "\nTool Color : R(" + DetailsList.get(4) + ") G(" + DetailsList.get(5) + ") B(" + DetailsList.get(6) + ")");
                    if (DetailsList.get(8) == 1) {
                        DetailsTxtr.append("\nFill Color : R(" + DetailsList.get(9) + ") G(" + DetailsList.get(10) + ") B(" + DetailsList.get(11) + ")");
                    } else {
                        DetailsTxtr.append("\nFill Color : Unfilled");
                    }
                    DetailsTxtr.append("\nStroke Size : " + DetailsList.get(7));
                    break;
                case 5:
                    DetailsTxtr.setText("Starting Point : (" + DetailsList.get(1) + "," + DetailsList.get(2) 
                            + ")\nMiddle Points : (" + DetailsList.get(3) + "," + DetailsList.get(4)
                            + "),(" + DetailsList.get(5) + "," + DetailsList.get(6)
                            + ")\nEnding Point : (" + DetailsList.get(7) + "," + DetailsList.get(8)
                            + ")\nTool Color : R(" + DetailsList.get(9) + ") G(" + DetailsList.get(10) + ") B(" + DetailsList.get(11) + ")");
                    if (DetailsList.get(13) == 1) {
                        DetailsTxtr.append("\nFill Color : R(" + DetailsList.get(14) + ") G(" + DetailsList.get(15) + ") B(" + DetailsList.get(16) + ")");
                    } else {
                        DetailsTxtr.append("\nFill Color : Unfilled");
                    }
                    DetailsTxtr.append("\nStroke Size : " + DetailsList.get(12));
                    break;
                case 6:
                    DetailsTxtr.setText("Starting Point : (" + DetailsList.get(1) + "," + DetailsList.get(2) 
                            + ")\nMiddle Points : (" + DetailsList.get(3) + "," + DetailsList.get(4)
                            + "),(" + DetailsList.get(5) + "," + DetailsList.get(6)
                            + "),(" + DetailsList.get(7) + "," + DetailsList.get(8)
                            + ")\nEnding Point : (" + DetailsList.get(9) + "," + DetailsList.get(10)
                            + ")\nTool Color : R(" + DetailsList.get(11) + ") G(" + DetailsList.get(12) + ") B(" + DetailsList.get(13) + ")");
                    if (DetailsList.get(15) == 1) {
                        DetailsTxtr.append("\nFill Color : R(" + DetailsList.get(16) + ") G(" + DetailsList.get(17) + ") B(" + DetailsList.get(18) + ")");
                    } else {
                        DetailsTxtr.append("\nFill Color : Unfilled");
                    }
                    DetailsTxtr.append("\nStroke Size : " + DetailsList.get(14));
                    break;
                case 7:
                    DetailsTxtr.setText("Starting Point : (" + DetailsList.get(1) + "," + DetailsList.get(2) 
                            + ")\nMiddle Point : (" + DetailsList.get(3) + "," + DetailsList.get(4)
                            + ")\nEnding Point : (" + DetailsList.get(5) + "," + DetailsList.get(6)
                            + ")\nTool Color : R(" + DetailsList.get(7) + ") G(" + DetailsList.get(8) + ") B(" + DetailsList.get(9)
                            + ")\nStroke Size : " + DetailsList.get(10));
                    break;
                case 8:
                    DetailsTxtr.setText("Starting Point : (" + DetailsList.get(1) + "," + DetailsList.get(2)
                            + ")\nEnding Point : (" + DetailsList.get(3) + "," + DetailsList.get(4)
                            + ")\nWidth : " + DetailsList.get(5) 
                            + "\nHeight : " + DetailsList.get(6)
                            + "\nTool Color : R(" + DetailsList.get(7) + ") G(" + DetailsList.get(8) + ") B(" + DetailsList.get(9) + ")");
                    if (DetailsList.get(11) == 1) {
                        DetailsTxtr.append("\nFill Color : R(" + DetailsList.get(12) + ") G(" + DetailsList.get(13) + ") B(" + DetailsList.get(14) + ")");
                    } else {
                        DetailsTxtr.append("\nFill Color : Unfilled");
                    }
                    DetailsTxtr.append("\nStroke Size : " + DetailsList.get(10));
                    
                    if (Objects.equals(DetailsList.get(5), DetailsList.get(6))) {
                        DetailsTxtr.append("\n\t(Square)");
                    }
                    break;
            }
    }

    public void ClearDrawPad() {
        Graphics g = DrawPad.getGraphics();
        g.setColor(backColor);
        g.fillRect(0, 0, DrawPadWidth, DrawPadHeight);
    }
      
    public void GetScanLines(int shapesX[], int shapesY[], int NumEdges) {
        for (int i = 0; i < NumEdges; i++) {
            if (i + 1 == NumEdges) {
                if (shapesY[i] != shapesY[0]) {
                    if (shapesY[i] > shapesY[0]) {
                        minY[i] = shapesY[0];
                        maxY[i] = shapesY[i];

                        valueX[i] = shapesX[0];
                    } else if (shapesY[i] < shapesY[0]){
                        minY[i] = shapesY[i];
                        maxY[i] = shapesY[0];

                        valueX[i] = shapesX[i];
                    }
                    slope[i] = (double) ( (double) (shapesX[i] - shapesX[0])/ (double) (shapesY[i] - shapesY[0]));
                }
            } else {
                if (shapesY[i] != shapesY[i + 1]) {
                    if (shapesY[i] > shapesY[i + 1]) {
                        minY[i] = shapesY[i + 1];
                        maxY[i] = shapesY[i];

                        valueX[i] = shapesX[i + 1];
                    } else if (shapesY[i] < shapesY[i + 1]) {
                        minY[i] = shapesY[i];
                        maxY[i] = shapesY[i + 1];

                        valueX[i] = shapesX[i];
                    }
                    slope[i] = (double) ( (double) (shapesX[i] - shapesX[i + 1])/ (double) (shapesY[i] - shapesY[i + 1]));
                }
            }
        }
    }
    
    public void SortScanLines(int minY[], int maxY[], double valueX[], double slope[], int NumEdges) {
        int maxIteration = NumEdges - 1;    // Bubble Sort algorithm will iterate maximum NumEdges - 1 times
        int numComparisons = maxIteration;  // The number of comparisons between the values will be initially equal to the maxIteration value
        
        int temp_minY;          // Temporary variables  
        int temp_maxY;          // which help in  
        double temp_valueX;     // sorting the 
        double temp_slope;      // arrays
        
        for (int i = 1; i <= maxIteration; i++) {
            for (int j = 1; j <= numComparisons; j++) {
                if ((minY[j - 1] > minY[j]) || ((minY[j - 1] == minY[j]) && (valueX[j - 1] > valueX[j]))) {
                    temp_minY = minY[j - 1];
                    temp_maxY = maxY[j - 1];
                    temp_valueX = valueX[j - 1];
                    temp_slope = slope[j - 1];
                    
                    minY[j - 1] = minY[j];
                    maxY[j - 1] = maxY[j];
                    valueX[j - 1] = valueX[j];
                    slope[j - 1] = slope[j];
                    
                    minY[j] = temp_minY;
                    maxY[j] = temp_maxY;
                    valueX[j] = temp_valueX;
                    slope[j] = temp_slope;
                }
            }
            numComparisons--;
        }
    }
    
    public void FillPolygon(int shapesX[], int shapesY[], int NumEdges, Color fillColor, int strokeSize) {
        boolean parity;                     // Odd parity -> true, even parity -> false
        int helpLength = minY.length;       // All the four arrays have the same length
        
        double[][] active_edges = new double[helpLength][4];            // Table of Active Edges (4 positions : minimum Y, maximum Y, value X, slope)
        
        for (int i = 0; i < helpLength; i++) {      // Initialize with -1 values in the first index of each row
            active_edges[i][0] = -1;
        }

        active_edges[0][0] = minY[0];       // Add the first 
        active_edges[0][1] = maxY[0];       // edge to the 
        active_edges[0][2] = valueX[0];     // active_edge
        active_edges[0][3] = slope[0];      // list
        
        for (int i = 1; i < helpLength; i++) {      // Add any other edges existing with the same minimum Y value, to the active edges' table
            if (minY[i] == minY[0]) {
                active_edges[i][0] = minY[i];
                active_edges[i][1] = maxY[i];
                active_edges[i][2] = valueX[i];
                active_edges[i][3] = slope[i];
            }
        }
        
        int maximumY = -1;
        
        for (int i = 0; i < helpLength; i++) {      // Get the maximum Y value of the polygon
            if (maximumY < maxY[i]) {
                maximumY = maxY[i];
            } 
        }

        int minimumY = (int) active_edges[0][0];    // Get the minimum Y value of the polygon
        int numOfScanLines = maximumY - minimumY;   // Get the number of scan lines
        
        for (int i = 0; i <= numOfScanLines; i++) {
            
            if (i == 0) {                                                       // For the first 
                int j = 0;                                                      // scan line, 
                while (active_edges[j][0] != -1) {                              // refresh the 
                    if (active_edges[j][0] != -1) {                             // X values by 
                        active_edges[j][2] += (double) active_edges[j][3];      // adding the 
                    }                                                           // corresponding 
                    j++;                                                        // slopes, without 
                }                                                               // checking possible 
                continue;                                                       // drawing conditions
            }
            
            int currentY = minimumY + i;            // Current Y value
            int temp_maximumX = -1;                 // Later the maximum X value of the current line will be assigned to this variable(for each line)
            
            for (int j = 1; j < helpLength; j++) {                      // Find the maximum X 
                if (active_edges[j][0] == -1) {                         // value of the current  
                    temp_maximumX = (int) active_edges[j - 1][2];       // line, in order to  
                    break;                                              // pre-fix the number of 
                }                                                       // iterations for this line             
            }
            
            parity = false;             // Always set the parity equal to false (even) before the scan line
            int currPosition = 0;       // The current position in the active edges table
            
            
            for (int currentX = (int) active_edges[0][2] - strokeSize; currentX <= temp_maximumX + strokeSize; currentX++) {      // Start from a couple of pixels left from the border
                if (!parity) {
                    int border = (int) active_edges[currPosition][2];
                    if (currentX == border) {
                        boolean isPoint = false;
                        for (int c = 0; c < minY.length; c++) {
                            if ((currentY == minY[c] || currentY == maxY[c]) && (currentX == valueX[c])) {
                                isPoint = true;
                            }
                        }
                        
                        if (!isPoint) {
                            parity = true;
                            currPosition++;
                            if (active_edges[currPosition][0] == -1) {              // Check if the current position in the active edges table is active
                                break;                                                  // If not, break from the for loop
                            }
                        } else {
                            int countYvalues = 0;                               // Helping variable 
                            for (int c = 0; c < minY.length; c++) {             // will be assigned 
                                if (currentY == minY[c]) {                      // the number of maxY 
                                    countYvalues--;                             // values (-2 for two 
                                } else if (currentY == maxY[c]) {               // minYs, 2 for two 
                                    countYvalues++;                             // maxYs, 0 for equality
                                }                                               // (one minY, one maxY))
                            }
                            
                            if ((countYvalues == -2) || (countYvalues == 2)) {  // Check the two edges have same directions(both up or down)
                                currPosition += 2;                                  // If so, increase the current position by 2
                                if (active_edges[currPosition][0] == -1) {          // Check if the current position in the active edges table is active
                                    break;                                              // If not, break from the for loop
                                }
                            } else if (countYvalues == 0) {                     // Check if the two edges have different directions(up and down)
                                parity = true;                                      // If so, change the parity to odd
                                currPosition++;                                     // and increase the current position by 1
                                if (active_edges[currPosition][0] == -1) {          // Check if the current position in the active edges table is active
                                    break;                                              // If not, break from the for loop
                                }
                            }
                        }
                    }
                } else {
                    int border = (int) active_edges[currPosition][2];
                    if (currentX < border) {
                        DrawPixel(currentX, currentY, fillColor, 1);
                    } else if (currentX == border) {
                        boolean isPoint = false;
                        for (int c = 0; c < minY.length; c++) {
                            if ((currentY == minY[c] || currentY == maxY[c]) && (currentX == valueX[c])) {
                                isPoint = true;
                            }
                        }
                        
                        if (!isPoint) {
                            parity = false;
                            currPosition++;
                            
                            if (active_edges[currPosition][0] == -1) {              // Check if the current position in the active edges table is active
                                break;                                                  // If not, break from the for loop
                            }
                            
                            if ((int) active_edges[currPosition][2] == (int) active_edges[currPosition - 1][2]) {
                                parity = true;
                                currPosition++;
                            }
                        } else {
                            int countYvalues = 0;                               // Helping variable 
                            for (int c = 0; c < minY.length; c++) {             // will be assigned 
                                if (currentY == minY[c]) {                      // the number of maxY 
                                    countYvalues--;                             // values (-2 for two 
                                } else if (currentY == maxY[c]) {               // minYs, 2 for two 
                                    countYvalues++;                             // maxYs, 0 for equality
                                }                                               // (one minY, one maxY))
                            }
                            
                            if ((countYvalues == -2) || (countYvalues == 2)) {  // Check the two edges have same directions(both up or down)
                                currPosition += 2;                                  // If so, increase the current position by 2
                                if (active_edges[currPosition][0] == -1) {          // Check if the current position in the active edges table is active
                                    break;                                              // If not, break from the for loop
                                }
                            } else if (countYvalues == 0) {                     // Check if the two edges have different directions(up and down)
                                parity = false;                                     // If so, change the parity to odd
                                currPosition++;                                     // and increase the current position by 1
                                if (active_edges[currPosition][0] == -1) {          // Check if the current position in the active edges table is active
                                    break;                                              // If not, break from the for loop
                                }
                            }
                        }
                    }
                }
            }
            
            int currentIndex = 0;
            
            while(active_edges[currentIndex][0] != -1) {                // Delete the unnecessary edges, which are the ones whoses' 
                if (active_edges[currentIndex][1] == currentY + 1) {    // maximum Y value will be equal to the next Y scan line
                    active_edges[currentIndex][0] = -1;
                } else if (currentIndex + 1 >= helpLength) {
                    break;
                }
                currentIndex++;     // After the exit from the while loop, the currentIndex variable, decreased by one, will hold the index of the last row (edge) that was not deleted from the table(if any)
            }
            
            for (int j = 0; j < currentIndex; j++) {        // Add each slope value to the matching X value
                if (active_edges[j][0] != -1) {
                    active_edges[j][2] += (double) active_edges[j][3];       // Add the slope(3) to the X value(2)
                }
            }

            for (int j = 0; j < helpLength; j++) {                    
                if (minY[j] == currentY + 1 ) {
                    active_edges[currentIndex][0] = minY[j];                // The first free space (except 
                    active_edges[currentIndex][1] = maxY[j];                // the possibly existing indexes 
                    active_edges[currentIndex][2] = (double) valueX[j];     // that were deleted) is saved 
                    active_edges[currentIndex][3] = (double) slope[j];      // in the currentIndex variable
                    currentIndex++;
                }
            }
            
            /* Fill the first positions in active edges table (if empty) */
            for (int j = 1; j < helpLength; j++) {
                if ((active_edges[j - 1][0] == -1) && (active_edges[j][0] != -1)) {     // Check if previous position is empty, and current position is active
                    active_edges[j - 1][0] = active_edges[j][0];                            // If so, save 
                    active_edges[j - 1][1] = active_edges[j][1];                            // the current 
                    active_edges[j - 1][2] = active_edges[j][2];                            // position to 
                    active_edges[j - 1][3] = active_edges[j][3];                            // the previous one
                    
                    active_edges[j][0] = -1;                                                // Set the current position to empty (inactive)
                } else if ((active_edges[j - 1][0] == -1) && (active_edges[j][0] == -1) && (j + 1 < helpLength)) {  // Check if both previous and current positions are empty and there is a next position
                    if (active_edges[j + 1][0] != -1) {                                                             // and if the next position is active
                        active_edges[j - 1][0] = active_edges[j + 1][0];                    // If so, save
                        active_edges[j - 1][1] = active_edges[j + 1][1];                    // the next 
                        active_edges[j - 1][2] = active_edges[j + 1][2];                    // position to 
                        active_edges[j - 1][3] = active_edges[j + 1][3];                    // the previous one

                        active_edges[j + 1][0] = -1;                                        // Set the next position to empty (inactive)
                    }
                }
            }

            int counter = 0;                            // Set a counter variable and
            for (int j = 0; j < helpLength; j++) {      // count the non-empty rows
                if (active_edges[j][0] != -1) {
                    counter++;
                }
            }
            
            int numComparisons = counter - 1;           // The number of comparisons between the values will be initially equal to the maxIteration value
            
            int temp_minY;          // Temporary variables  
            int temp_maxY;          // which help in  
            double temp_valueX;     // sorting the 
            double temp_slope;      // arrays

            /* Sort the active edges' table */
            for (int j = 1; j <= counter - 1; j++) {
                for (int c = 1; c <= numComparisons; c++) {
                    if ((active_edges[c - 1][2] > active_edges[c][2])) {
                        temp_minY = (int) active_edges[c - 1][0];
                        temp_maxY = (int) active_edges[c - 1][1];
                        temp_valueX = active_edges[c - 1][2];
                        temp_slope = active_edges[c - 1][3];

                        active_edges[c - 1][0] = active_edges[c][0];
                        active_edges[c - 1][1] = active_edges[c][1];
                        active_edges[c - 1][2] = active_edges[c][2];
                        active_edges[c - 1][3] = active_edges[c][3];

                        active_edges[c][0] = temp_minY;
                        active_edges[c][1] = temp_maxY;
                        active_edges[c][2] = temp_valueX;
                        active_edges[c][3] = temp_slope;
                    }
                }
                numComparisons--;
            }
        }
    }
    
    /* <---- Till here ----> */
    
    /*
     * @param args the command line arguments
     */
    
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(GUIFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new GUIFrame().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton BackgroundColorBtn;
    private javax.swing.JLabel BackgroundColorLbl;
    private javax.swing.JButton CircleBtn;
    private javax.swing.JButton ClearBtn;
    private javax.swing.JLabel ColorLbl;
    private javax.swing.JLabel CoordinatesLbl;
    private javax.swing.JButton CrookedLineBtn;
    private javax.swing.JButton DeleteBtn;
    private javax.swing.JPanel DemoPnl;
    private javax.swing.JLabel DetailsLbl;
    private javax.swing.JScrollPane DetailsScrollPnl;
    private javax.swing.JTextArea DetailsTxtr;
    private javax.swing.JButton DownBtn;
    private javax.swing.JPanel DrawPad;
    private javax.swing.JButton EditBtn;
    private javax.swing.JComboBox FillColorCmbBx;
    private javax.swing.JLabel FillColorLbl;
    private javax.swing.JButton LineBtn;
    private javax.swing.JPanel ListPnl;
    private javax.swing.JLabel ListShapesLbl;
    private javax.swing.JButton PencilBtn;
    private javax.swing.JComboBox PolygonCmbBx;
    private javax.swing.JButton RectangularBtn;
    private javax.swing.JButton RefreshBtn;
    private javax.swing.JButton ResizeBtn;
    private javax.swing.JScrollPane ScrollDrawPad;
    private javax.swing.JPanel ScrollPnl;
    private javax.swing.JScrollPane ScrollShapesLst;
    private javax.swing.JList ShapesLst;
    private javax.swing.JButton SquareBtn;
    private javax.swing.JLabel StrokeLbl;
    private javax.swing.JSlider StrokeSldr;
    private javax.swing.JButton ToolColorBtn;
    private javax.swing.JLabel ToolColorLbl;
    private javax.swing.JLabel ToolShapesLbl;
    private javax.swing.JSeparator ToolSprtr1;
    private javax.swing.JSeparator ToolSprtr2;
    private javax.swing.JSeparator ToolSprtr3;
    private javax.swing.JPanel ToolsPnl;
    private javax.swing.JButton TriangleBtn;
    private javax.swing.JButton UpBtn;
    // End of variables declaration//GEN-END:variables
}
